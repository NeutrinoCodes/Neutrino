/// @file     linear_algebra.cpp
/// @author   Erik ZORZIN
/// @date     24OCT2019
/// @brief    Definition of various linear algebra functions.

#include "linear_algebra.hpp"

float   dot
(
 float a[3],                                                                                        // 3D Vector.
 float b[3]                                                                                         // 3D Vector.
)
{
  return(a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);                                                        // Returning dot product...
}

float   magnitude
(
 float a[3]                                                                                         // 3D Vector.
)
{
  return sqrt (dot (a, a));                                                                         // Returning magnitude...
}

void    normalize
(
 float a[3]                                                                                         // 3D Vector.
)
{
  float mag;                                                                                        // Magnitude.

  mag = magnitude (a);                                                                              // Getting magnitude...

  if(mag != 0.0f)                                                                                   // Normalizable vector:
  {
    a[0] /= mag;                                                                                    // Normalizing...
    a[1] /= mag;                                                                                    // Normalizing...
    a[2] /= mag;                                                                                    // Normalizing...
  }

  else // Non-normalizable vector:
  {
    a[0] = 0.0f;                                                                                    // Setting component to zero...
    a[1] = 0.0f;                                                                                    // Setting component to zero...
    a[2] = 0.0f;                                                                                    // Setting component to zero...
  }
}

float   angle
(
 float a[3],                                                                                        // 3D Vector.
 float b[3]                                                                                         // 3D Vector.
)
{
  float u[3];                                                                                       // Normalized vector.
  float v[3];                                                                                       // Normalized vector.
  float theta;                                                                                      // Angle between vectors.
  float cos_theta;                                                                                  // Cosine of angle between vectors.

  u[0]      = a[0];                                                                                 // Getting 1st vector "x" component...
  u[1]      = a[1];                                                                                 // Getting 1st vector "y" component...
  u[2]      = a[2];                                                                                 // Getting 1st vector "z" component...

  v[0]      = b[0];                                                                                 // Getting 2nd vector "x" component...
  v[1]      = b[1];                                                                                 // Getting 2nd vector "y" component...
  v[2]      = b[2];                                                                                 // Getting 2nd vector "z" component...

  normalize (u);                                                                                    // Normalizing vector...
  normalize (v);                                                                                    // Normalizing vector...

  cos_theta = dot (u, v);                                                                           // Computing cos_theta...

  // Fixing numerical approximation errors in cosine computation:
  if(cos_theta > 1.0f)                                                                              // Clamping cos_theta...
  {
    cos_theta = 1.0f;                                                                               // Setting cos_theta maximum value...
  }

  if(cos_theta < -1.0f)                                                                             // Clamping cos_theta...
  {
    cos_theta = -1.0f;                                                                              // Setting cos_theta minimum value...
  }

  theta = acos (cos_theta);                                                                         // Computing theta...

  return theta;                                                                                     // Returning cos_theta...
}

void  cross
(
 float v[3],                                                                                        // 3D cross product vector.
 float a[3],                                                                                        // 3D Vector.
 float b[3]                                                                                         // 3D Vector.
)
{
  v[0] = +(a[1]*b[2] - a[2]*b[1]);                                                                  // Computing cross product...
  v[1] = -(a[0]*b[2] - a[2]*b[0]);                                                                  // Computing cross product...
  v[2] = +(a[0]*b[1] - a[1]*b[0]);                                                                  // Computing cross product...
}

void  quaternion
(
 float q[4],                                                                                        // Rotation quaternion.
 float axis[3],                                                                                     // 3D rotation axis vector.
 float theta                                                                                        // Rotation angle [rad].
)
{
  float cos_theta_half;                                                                             // cos(theta/2).
  float sin_theta_half;                                                                             // sin(theta/2).

  cos_theta_half = cos (theta/2.0f);                                                                // Computing cos(theta/2)...
  sin_theta_half = sin (theta/2.0f);                                                                // Computing sin(theta/2)...

  // EZOR: 05MAY2022 Should I normalize the axis?
  //normalize(axis);                                                              // Normalizing rotation axis...

  q[0]           = axis[0]*sin_theta_half;                                                          // Computing rotation quaternion...
  q[1]           = axis[1]*sin_theta_half;                                                          // Computing rotation quaternion...
  q[2]           = axis[2]*sin_theta_half;                                                          // Computing rotation quaternion...
  q[3]           = cos_theta_half;                                                                  // Computing rotation quaternion...
}

void  rotation_matrix
(
 float M[9],                                                                                        // 3x3 rotation matrix.
 float q[4]                                                                                         // Rotation quaternion.
)
{
  float mag;                                                                                        // Quaternion magnitude.

  float x2, xx, xy, xz;                                                                             // Matrix "x*" terms.
  float y2, yy, yz;                                                                                 // Matrix "y*" terms.
  float z2, zz;                                                                                     // Matrix "z*" terms.
  float wx, wy, wz;                                                                                 // Matrix "w*" terms.

  mag   = sqrt (q[0]*q[0] + q[1]*q[1] + q[2]*q[2] + q[3]*q[3]);                                     // Computing quaternion's magnitude...

  q[0] /= mag;                                                                                      // Normalizing quaternion...
  q[1] /= mag;                                                                                      // Normalizing quaternion...
  q[2] /= mag;                                                                                      // Normalizing quaternion...
  q[3] /= mag;                                                                                      // Normalizing quaternion...

  x2    = q[0] + q[0];                                                                              // Computing matrix term...
  y2    = q[1] + q[1];                                                                              // Computing matrix term...
  z2    = q[2] + q[2];                                                                              // Computing matrix term...

  xx    = q[0]*x2;                                                                                  // Computing matrix term...
  xy    = q[0]*y2;                                                                                  // Computing matrix term...
  xz    = q[0]*z2;                                                                                  // Computing matrix term...
  yy    = q[1]*y2;                                                                                  // Computing matrix term...
  yz    = q[1]*z2;                                                                                  // Computing matrix term...
  zz    = q[2]*z2;                                                                                  // Computing matrix term...
  wx    = q[3]*x2;                                                                                  // Computing matrix term...
  wy    = q[3]*y2;                                                                                  // Computing matrix term...
  wz    = q[3]*z2;                                                                                  // Computing matrix term...

  M[0]  = 1.0f - (yy + zz); M[3] = 0.0f + (xy - wz); M[6] = 0.0f + (xz + wy);                       // Computing rotation matrix...
  M[1]  = 0.0f + (xy + wz); M[4] = 1.0f - (xx + zz); M[7] = 0.0f + (yz - wx);                       // Computing rotation matrix...
  M[2]  = 0.0f + (xz - wy); M[5] = 0.0f + (yz + wx); M[8] = 1.0f - (xx + yy);                       // Computing rotation matrix...
}

void  euler
(
 float* roll,                                                                                       // Roll angle [rad].
 float* pitch,                                                                                      // Pitch angle [rad].
 float* yaw,                                                                                        // Yaw angle [rad].
 float  q[4]                                                                                        // Rotation quaternion.
)
{
  float sinr_cosp = +0.0f + 2.0f*(q[3]*q[0] + q[1]*q[2]);                                           // Computing intermediate result...
  float cosr_cosp = +1.0f - 2.0f*(q[0]*q[0] + q[1]*q[1]);                                           // Computing intermediate result...
  float siny_cosp = +0.0f + 2.0f*(q[3]*q[2] + q[0]*q[1]);                                           // Computing intermediate result...
  float cosy_cosp = +1.0f - 2.0f*(q[1]*q[1] + q[2]*q[2]);                                           // Computing intermediate result...
  float sinp      = +0.0f + 2.0f*(q[3]*q[1] - q[2]*q[0]);                                           // Computing intermediate result...

  // Roll (x-axis rotation):
  *roll = atan2 (sinr_cosp, cosr_cosp);                                                             // Computing roll...

  // Pitch (y-axis rotation):
  if(fabs (sinp) >= 1.0f)
  {
    *pitch = copysign ((float)M_PI/2.0f, sinp);                                                     // Using PI/2 if out of range...
  }

  else
  {
    *pitch = asin (sinp);                                                                           // Computing pitch...
  }

  // Yaw (z-axis rotation):
  *yaw = atan2 (siny_cosp, cosy_cosp);                                                              // Computing yaw...
}

void inv (
          float I[16],                                                                              // Inverse of input matrix.
          float M[16]                                                                               // Input matrix.
         )
{
  float I_temp[16];                                                                                 // Temporary matrix...
  int   i;

  float A2323 = M[10]*M[15] - M[11]*M[14];                                                          // Computing matrix coefficient...
  float A1323 = M[9]*M[15] - M[11]*M[13];                                                           // Computing matrix coefficient...
  float A1223 = M[9]*M[14] - M[10]*M[13];                                                           // Computing matrix coefficient...
  float A0323 = M[8]*M[15] - M[11]*M[12];                                                           // Computing matrix coefficient...
  float A0223 = M[8]*M[14] - M[10]*M[12];                                                           // Computing matrix coefficient...
  float A0123 = M[8]*M[13] - M[9]*M[12];                                                            // Computing matrix coefficient...
  float A2313 = M[6]*M[15] - M[7]*M[14];                                                            // Computing matrix coefficient...
  float A1313 = M[5]*M[15] - M[7]*M[13];                                                            // Computing matrix coefficient...
  float A1213 = M[5]*M[14] - M[6]*M[13];                                                            // Computing matrix coefficient...
  float A2312 = M[6]*M[11] - M[7]*M[10];                                                            // Computing matrix coefficient...
  float A1312 = M[5]*M[11] - M[7]*M[9];                                                             // Computing matrix coefficient...
  float A1212 = M[5]*M[10] - M[6]*M[9];                                                             // Computing matrix coefficient...
  float A0313 = M[4]*M[15] - M[7]*M[12];                                                            // Computing matrix coefficient...
  float A0213 = M[4]*M[14] - M[6]*M[12];                                                            // Computing matrix coefficient...
  float A0312 = M[4]*M[11] - M[7]*M[8];                                                             // Computing matrix coefficient...
  float A0212 = M[4]*M[10] - M[6]*M[8];                                                             // Computing matrix coefficient...
  float A0113 = M[4]*M[13] - M[5]*M[12];                                                            // Computing matrix coefficient...
  float A0112 = M[4]*M[9] - M[5]*M[8];                                                              // Computing matrix coefficient...

  float det   = +M[0]*(M[5]*A2323 - M[6]*A1323 + M[7]*A1223)                                        // Computing determinant...
                - M[1]*(M[4]*A2323 - M[6]*A0323 + M[7]*A0223)
                + M[2]*(M[4]*A1323 - M[5]*A0323 + M[7]*A0123)
                - M[3]*(M[4]*A1223 - M[5]*A0223 + M[6]*A0123);

  if(det > 0)                                                                                       // Checking determinant...
  {
    det        = 1.0f/det;

    I_temp[0]  = det* +(M[5]*A2323 - M[6]*A1323 + M[7]*A1223);                                      // Computing temporary inverse matrix...
    I_temp[1]  = det* -(M[1]*A2323 - M[2]*A1323 + M[3]*A1223);                                      // Computing temporary inverse matrix...
    I_temp[2]  = det* +(M[1]*A2313 - M[2]*A1313 + M[3]*A1213);                                      // Computing temporary inverse matrix...
    I_temp[3]  = det* -(M[1]*A2312 - M[2]*A1312 + M[3]*A1212);                                      // Computing temporary inverse matrix...
    I_temp[4]  = det* -(M[4]*A2323 - M[6]*A0323 + M[7]*A0223);                                      // Computing temporary inverse matrix...
    I_temp[5]  = det* +(M[0]*A2323 - M[2]*A0323 + M[3]*A0223);                                      // Computing temporary inverse matrix...
    I_temp[6]  = det* -(M[0]*A2313 - M[2]*A0313 + M[3]*A0213);                                      // Computing temporary inverse matrix...
    I_temp[7]  = det* +(M[0]*A2312 - M[2]*A0312 + M[3]*A0212);                                      // Computing temporary inverse matrix...
    I_temp[8]  = det* +(M[4]*A1323 - M[5]*A0323 + M[7]*A0123);                                      // Computing temporary inverse matrix...
    I_temp[9]  = det* -(M[0]*A1323 - M[1]*A0323 + M[3]*A0123);                                      // Computing temporary inverse matrix...
    I_temp[10] = det* +(M[0]*A1313 - M[1]*A0313 + M[3]*A0113);                                      // Computing temporary inverse matrix...
    I_temp[11] = det* -(M[0]*A1312 - M[1]*A0312 + M[3]*A0112);                                      // Computing temporary inverse matrix...
    I_temp[12] = det* -(M[4]*A1223 - M[5]*A0223 + M[6]*A0123);                                      // Computing temporary inverse matrix...
    I_temp[13] = det* +(M[0]*A1223 - M[1]*A0223 + M[2]*A0123);                                      // Computing temporary inverse matrix...
    I_temp[14] = det* -(M[0]*A1213 - M[1]*A0213 + M[2]*A0113);                                      // Computing temporary inverse matrix...
    I_temp[15] = det* +(M[0]*A1212 - M[1]*A0212 + M[2]*A0112);                                      // Computing temporary inverse matrix...
  }
  else
  {
    for(i = 0; i < 16; i++)
    {
      I_temp[i] = 0.0f;                                                                             // Setting temporary inverse matrix to zero, if the input matrix is not invertible...
    }
  }

  for(i = 0; i < 16; i++)
  {
    I[i] = I_temp[i];                                                                               // Updating inverse matrix...
  }
}

